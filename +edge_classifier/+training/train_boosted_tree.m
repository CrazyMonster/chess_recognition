function [trainedClassifier, validationAccuracy] = train_boosted_tree(trainingData)
% [trainedClassifier, validationAccuracy] = train_boosted_tree(trainingData)
% returns a trained classifier and its accuracy. This code recreates the
% classification model trained in Classification Learner app. Use the
% generated code to automate training the same model with new data, or to
% learn how to programmatically train models.
%
%  Input:
%      trainingData: a table containing the same predictor and response
%       columns as imported into the app.
%
%  Output:
%      trainedClassifier: a struct containing the trained classifier. The
%       struct contains various fields with information about the trained
%       classifier.
%
%      trainedClassifier.predictFcn: a function to make predictions on new
%       data.
%
%      validationAccuracy: a double containing the accuracy in percent. In
%       the app, the History list displays this overall accuracy score for
%       each model.
%
% Use the code to train the model with new data. To retrain your
% classifier, call the function from the command line with your original
% data or new data as the input argument trainingData.
%
% For example, to retrain a classifier trained with the original data set
% T, enter:
%   [trainedClassifier, validationAccuracy] = trainClassifier(T)
%
% To make predictions with the returned 'trainedClassifier' on new data T2,
% use
%   yfit = trainedClassifier.predictFcn(T2)
%
% T2 must be a table containing at least the same predictor columns as used
% during training. For details, enter:
%   trainedClassifier.HowToPredict

% Auto-generated by MATLAB on 30-Jan-2018 22:05:22


% Extract predictors and response
% This code processes the data into the right shape for training the
% model.
inputTable = trainingData;
% Split matrices in the input table into vectors
inputTable = [inputTable(:,setdiff(inputTable.Properties.VariableNames, {'Centroid_A', 'BoundingBox_A', 'LBP_A', 'Centroid_B', 'BoundingBox_B', 'LBP_B', 'LBP_Delta'})), array2table(table2array(inputTable(:,{'Centroid_A', 'BoundingBox_A', 'LBP_A', 'Centroid_B', 'BoundingBox_B', 'LBP_B', 'LBP_Delta'})), 'VariableNames', {'Centroid_A_1', 'Centroid_A_2', 'BoundingBox_A_1', 'BoundingBox_A_2', 'BoundingBox_A_3', 'BoundingBox_A_4', 'LBP_A_1', 'LBP_A_2', 'LBP_A_3', 'LBP_A_4', 'LBP_A_5', 'LBP_A_6', 'LBP_A_7', 'LBP_A_8', 'LBP_A_9', 'LBP_A_10', 'LBP_A_11', 'LBP_A_12', 'LBP_A_13', 'LBP_A_14', 'LBP_A_15', 'LBP_A_16', 'LBP_A_17', 'LBP_A_18', 'LBP_A_19', 'LBP_A_20', 'LBP_A_21', 'LBP_A_22', 'LBP_A_23', 'LBP_A_24', 'LBP_A_25', 'LBP_A_26', 'LBP_A_27', 'LBP_A_28', 'LBP_A_29', 'LBP_A_30', 'LBP_A_31', 'LBP_A_32', 'LBP_A_33', 'LBP_A_34', 'LBP_A_35', 'LBP_A_36', 'LBP_A_37', 'LBP_A_38', 'LBP_A_39', 'LBP_A_40', 'LBP_A_41', 'LBP_A_42', 'LBP_A_43', 'LBP_A_44', 'LBP_A_45', 'LBP_A_46', 'LBP_A_47', 'LBP_A_48', 'LBP_A_49', 'LBP_A_50', 'LBP_A_51', 'LBP_A_52', 'LBP_A_53', 'LBP_A_54', 'LBP_A_55', 'LBP_A_56', 'LBP_A_57', 'LBP_A_58', 'LBP_A_59', 'Centroid_B_1', 'Centroid_B_2', 'BoundingBox_B_1', 'BoundingBox_B_2', 'BoundingBox_B_3', 'BoundingBox_B_4', 'LBP_B_1', 'LBP_B_2', 'LBP_B_3', 'LBP_B_4', 'LBP_B_5', 'LBP_B_6', 'LBP_B_7', 'LBP_B_8', 'LBP_B_9', 'LBP_B_10', 'LBP_B_11', 'LBP_B_12', 'LBP_B_13', 'LBP_B_14', 'LBP_B_15', 'LBP_B_16', 'LBP_B_17', 'LBP_B_18', 'LBP_B_19', 'LBP_B_20', 'LBP_B_21', 'LBP_B_22', 'LBP_B_23', 'LBP_B_24', 'LBP_B_25', 'LBP_B_26', 'LBP_B_27', 'LBP_B_28', 'LBP_B_29', 'LBP_B_30', 'LBP_B_31', 'LBP_B_32', 'LBP_B_33', 'LBP_B_34', 'LBP_B_35', 'LBP_B_36', 'LBP_B_37', 'LBP_B_38', 'LBP_B_39', 'LBP_B_40', 'LBP_B_41', 'LBP_B_42', 'LBP_B_43', 'LBP_B_44', 'LBP_B_45', 'LBP_B_46', 'LBP_B_47', 'LBP_B_48', 'LBP_B_49', 'LBP_B_50', 'LBP_B_51', 'LBP_B_52', 'LBP_B_53', 'LBP_B_54', 'LBP_B_55', 'LBP_B_56', 'LBP_B_57', 'LBP_B_58', 'LBP_B_59', 'LBP_Delta_1', 'LBP_Delta_2', 'LBP_Delta_3', 'LBP_Delta_4', 'LBP_Delta_5', 'LBP_Delta_6', 'LBP_Delta_7', 'LBP_Delta_8', 'LBP_Delta_9', 'LBP_Delta_10', 'LBP_Delta_11', 'LBP_Delta_12', 'LBP_Delta_13', 'LBP_Delta_14', 'LBP_Delta_15', 'LBP_Delta_16', 'LBP_Delta_17', 'LBP_Delta_18', 'LBP_Delta_19', 'LBP_Delta_20', 'LBP_Delta_21', 'LBP_Delta_22', 'LBP_Delta_23', 'LBP_Delta_24', 'LBP_Delta_25', 'LBP_Delta_26', 'LBP_Delta_27', 'LBP_Delta_28', 'LBP_Delta_29', 'LBP_Delta_30', 'LBP_Delta_31', 'LBP_Delta_32', 'LBP_Delta_33', 'LBP_Delta_34', 'LBP_Delta_35', 'LBP_Delta_36', 'LBP_Delta_37', 'LBP_Delta_38', 'LBP_Delta_39', 'LBP_Delta_40', 'LBP_Delta_41', 'LBP_Delta_42', 'LBP_Delta_43', 'LBP_Delta_44', 'LBP_Delta_45', 'LBP_Delta_46', 'LBP_Delta_47', 'LBP_Delta_48', 'LBP_Delta_49', 'LBP_Delta_50', 'LBP_Delta_51', 'LBP_Delta_52', 'LBP_Delta_53', 'LBP_Delta_54', 'LBP_Delta_55', 'LBP_Delta_56', 'LBP_Delta_57', 'LBP_Delta_58', 'LBP_Delta_59'})];

predictorNames = {'RegionCount', 'Region_A', 'Area_A', 'Centroid_A_1', 'Centroid_A_2', 'BoundingBox_A_1', 'BoundingBox_A_2', 'BoundingBox_A_3', 'BoundingBox_A_4', 'MajorAxisLength_A', 'MinorAxisLength_A', 'Eccentricity_A', 'Orientation_A', 'ConvexArea_A', 'FilledArea_A', 'EulerNumber_A', 'EquivDiameter_A', 'Solidity_A', 'Extent_A', 'Perimeter_A', 'LBP_A_1', 'LBP_A_2', 'LBP_A_3', 'LBP_A_4', 'LBP_A_5', 'LBP_A_6', 'LBP_A_7', 'LBP_A_8', 'LBP_A_9', 'LBP_A_10', 'LBP_A_11', 'LBP_A_12', 'LBP_A_13', 'LBP_A_14', 'LBP_A_15', 'LBP_A_16', 'LBP_A_17', 'LBP_A_18', 'LBP_A_19', 'LBP_A_20', 'LBP_A_21', 'LBP_A_22', 'LBP_A_23', 'LBP_A_24', 'LBP_A_25', 'LBP_A_26', 'LBP_A_27', 'LBP_A_28', 'LBP_A_29', 'LBP_A_30', 'LBP_A_31', 'LBP_A_32', 'LBP_A_33', 'LBP_A_34', 'LBP_A_35', 'LBP_A_36', 'LBP_A_37', 'LBP_A_38', 'LBP_A_39', 'LBP_A_40', 'LBP_A_41', 'LBP_A_42', 'LBP_A_43', 'LBP_A_44', 'LBP_A_45', 'LBP_A_46', 'LBP_A_47', 'LBP_A_48', 'LBP_A_49', 'LBP_A_50', 'LBP_A_51', 'LBP_A_52', 'LBP_A_53', 'LBP_A_54', 'LBP_A_55', 'LBP_A_56', 'LBP_A_57', 'LBP_A_58', 'LBP_A_59', 'Region_B', 'Area_B', 'Centroid_B_1', 'Centroid_B_2', 'BoundingBox_B_1', 'BoundingBox_B_2', 'BoundingBox_B_3', 'BoundingBox_B_4', 'MajorAxisLength_B', 'MinorAxisLength_B', 'Eccentricity_B', 'Orientation_B', 'ConvexArea_B', 'FilledArea_B', 'EulerNumber_B', 'EquivDiameter_B', 'Solidity_B', 'Extent_B', 'Perimeter_B', 'LBP_B_1', 'LBP_B_2', 'LBP_B_3', 'LBP_B_4', 'LBP_B_5', 'LBP_B_6', 'LBP_B_7', 'LBP_B_8', 'LBP_B_9', 'LBP_B_10', 'LBP_B_11', 'LBP_B_12', 'LBP_B_13', 'LBP_B_14', 'LBP_B_15', 'LBP_B_16', 'LBP_B_17', 'LBP_B_18', 'LBP_B_19', 'LBP_B_20', 'LBP_B_21', 'LBP_B_22', 'LBP_B_23', 'LBP_B_24', 'LBP_B_25', 'LBP_B_26', 'LBP_B_27', 'LBP_B_28', 'LBP_B_29', 'LBP_B_30', 'LBP_B_31', 'LBP_B_32', 'LBP_B_33', 'LBP_B_34', 'LBP_B_35', 'LBP_B_36', 'LBP_B_37', 'LBP_B_38', 'LBP_B_39', 'LBP_B_40', 'LBP_B_41', 'LBP_B_42', 'LBP_B_43', 'LBP_B_44', 'LBP_B_45', 'LBP_B_46', 'LBP_B_47', 'LBP_B_48', 'LBP_B_49', 'LBP_B_50', 'LBP_B_51', 'LBP_B_52', 'LBP_B_53', 'LBP_B_54', 'LBP_B_55', 'LBP_B_56', 'LBP_B_57', 'LBP_B_58', 'LBP_B_59', 'Region_Delta', 'Area_Delta', 'MajorAxisLength_Delta', 'MinorAxisLength_Delta', 'Eccentricity_Delta', 'Orientation_Delta', 'ConvexArea_Delta', 'FilledArea_Delta', 'EulerNumber_Delta', 'EquivDiameter_Delta', 'Solidity_Delta', 'Extent_Delta', 'Perimeter_Delta', 'LBP_Delta_1', 'LBP_Delta_2', 'LBP_Delta_3', 'LBP_Delta_4', 'LBP_Delta_5', 'LBP_Delta_6', 'LBP_Delta_7', 'LBP_Delta_8', 'LBP_Delta_9', 'LBP_Delta_10', 'LBP_Delta_11', 'LBP_Delta_12', 'LBP_Delta_13', 'LBP_Delta_14', 'LBP_Delta_15', 'LBP_Delta_16', 'LBP_Delta_17', 'LBP_Delta_18', 'LBP_Delta_19', 'LBP_Delta_20', 'LBP_Delta_21', 'LBP_Delta_22', 'LBP_Delta_23', 'LBP_Delta_24', 'LBP_Delta_25', 'LBP_Delta_26', 'LBP_Delta_27', 'LBP_Delta_28', 'LBP_Delta_29', 'LBP_Delta_30', 'LBP_Delta_31', 'LBP_Delta_32', 'LBP_Delta_33', 'LBP_Delta_34', 'LBP_Delta_35', 'LBP_Delta_36', 'LBP_Delta_37', 'LBP_Delta_38', 'LBP_Delta_39', 'LBP_Delta_40', 'LBP_Delta_41', 'LBP_Delta_42', 'LBP_Delta_43', 'LBP_Delta_44', 'LBP_Delta_45', 'LBP_Delta_46', 'LBP_Delta_47', 'LBP_Delta_48', 'LBP_Delta_49', 'LBP_Delta_50', 'LBP_Delta_51', 'LBP_Delta_52', 'LBP_Delta_53', 'LBP_Delta_54', 'LBP_Delta_55', 'LBP_Delta_56', 'LBP_Delta_57', 'LBP_Delta_58', 'LBP_Delta_59'};
predictors = inputTable(:, predictorNames);
response = inputTable.Relevance;

% Train a classifier
% This code specifies all the classifier options and trains the classifier.
template = templateTree();
optVars = hyperparameters('fitcensemble', predictors, response, template);

optVars(2).Range = [10, 100];

optVars(5).Range = [1, 30];
optVars(5).Optimize = true;

optVars(7).Optimize = true;

options.UseParallel = true;
options.MaxObjectiveEvaluations = 40;

classificationEnsemble = fitcensemble(...
    predictors, ...
    response, ...
    'Learners', template, ...
    'ClassNames', ['00'; '01'; '10'; '11'],...
    'OptimizeHyperparameters', optVars, ...
    'HyperparameterOptimizationOptions', options);

% Create the result struct with predict function
splitMatricesInTableFcn = @(t) [t(:,setdiff(t.Properties.VariableNames, {'Centroid_A', 'BoundingBox_A', 'LBP_A', 'Centroid_B', 'BoundingBox_B', 'LBP_B', 'LBP_Delta'})), array2table(table2array(t(:,{'Centroid_A', 'BoundingBox_A', 'LBP_A', 'Centroid_B', 'BoundingBox_B', 'LBP_B', 'LBP_Delta'})), 'VariableNames', {'Centroid_A_1', 'Centroid_A_2', 'BoundingBox_A_1', 'BoundingBox_A_2', 'BoundingBox_A_3', 'BoundingBox_A_4', 'LBP_A_1', 'LBP_A_2', 'LBP_A_3', 'LBP_A_4', 'LBP_A_5', 'LBP_A_6', 'LBP_A_7', 'LBP_A_8', 'LBP_A_9', 'LBP_A_10', 'LBP_A_11', 'LBP_A_12', 'LBP_A_13', 'LBP_A_14', 'LBP_A_15', 'LBP_A_16', 'LBP_A_17', 'LBP_A_18', 'LBP_A_19', 'LBP_A_20', 'LBP_A_21', 'LBP_A_22', 'LBP_A_23', 'LBP_A_24', 'LBP_A_25', 'LBP_A_26', 'LBP_A_27', 'LBP_A_28', 'LBP_A_29', 'LBP_A_30', 'LBP_A_31', 'LBP_A_32', 'LBP_A_33', 'LBP_A_34', 'LBP_A_35', 'LBP_A_36', 'LBP_A_37', 'LBP_A_38', 'LBP_A_39', 'LBP_A_40', 'LBP_A_41', 'LBP_A_42', 'LBP_A_43', 'LBP_A_44', 'LBP_A_45', 'LBP_A_46', 'LBP_A_47', 'LBP_A_48', 'LBP_A_49', 'LBP_A_50', 'LBP_A_51', 'LBP_A_52', 'LBP_A_53', 'LBP_A_54', 'LBP_A_55', 'LBP_A_56', 'LBP_A_57', 'LBP_A_58', 'LBP_A_59', 'Centroid_B_1', 'Centroid_B_2', 'BoundingBox_B_1', 'BoundingBox_B_2', 'BoundingBox_B_3', 'BoundingBox_B_4', 'LBP_B_1', 'LBP_B_2', 'LBP_B_3', 'LBP_B_4', 'LBP_B_5', 'LBP_B_6', 'LBP_B_7', 'LBP_B_8', 'LBP_B_9', 'LBP_B_10', 'LBP_B_11', 'LBP_B_12', 'LBP_B_13', 'LBP_B_14', 'LBP_B_15', 'LBP_B_16', 'LBP_B_17', 'LBP_B_18', 'LBP_B_19', 'LBP_B_20', 'LBP_B_21', 'LBP_B_22', 'LBP_B_23', 'LBP_B_24', 'LBP_B_25', 'LBP_B_26', 'LBP_B_27', 'LBP_B_28', 'LBP_B_29', 'LBP_B_30', 'LBP_B_31', 'LBP_B_32', 'LBP_B_33', 'LBP_B_34', 'LBP_B_35', 'LBP_B_36', 'LBP_B_37', 'LBP_B_38', 'LBP_B_39', 'LBP_B_40', 'LBP_B_41', 'LBP_B_42', 'LBP_B_43', 'LBP_B_44', 'LBP_B_45', 'LBP_B_46', 'LBP_B_47', 'LBP_B_48', 'LBP_B_49', 'LBP_B_50', 'LBP_B_51', 'LBP_B_52', 'LBP_B_53', 'LBP_B_54', 'LBP_B_55', 'LBP_B_56', 'LBP_B_57', 'LBP_B_58', 'LBP_B_59', 'LBP_Delta_1', 'LBP_Delta_2', 'LBP_Delta_3', 'LBP_Delta_4', 'LBP_Delta_5', 'LBP_Delta_6', 'LBP_Delta_7', 'LBP_Delta_8', 'LBP_Delta_9', 'LBP_Delta_10', 'LBP_Delta_11', 'LBP_Delta_12', 'LBP_Delta_13', 'LBP_Delta_14', 'LBP_Delta_15', 'LBP_Delta_16', 'LBP_Delta_17', 'LBP_Delta_18', 'LBP_Delta_19', 'LBP_Delta_20', 'LBP_Delta_21', 'LBP_Delta_22', 'LBP_Delta_23', 'LBP_Delta_24', 'LBP_Delta_25', 'LBP_Delta_26', 'LBP_Delta_27', 'LBP_Delta_28', 'LBP_Delta_29', 'LBP_Delta_30', 'LBP_Delta_31', 'LBP_Delta_32', 'LBP_Delta_33', 'LBP_Delta_34', 'LBP_Delta_35', 'LBP_Delta_36', 'LBP_Delta_37', 'LBP_Delta_38', 'LBP_Delta_39', 'LBP_Delta_40', 'LBP_Delta_41', 'LBP_Delta_42', 'LBP_Delta_43', 'LBP_Delta_44', 'LBP_Delta_45', 'LBP_Delta_46', 'LBP_Delta_47', 'LBP_Delta_48', 'LBP_Delta_49', 'LBP_Delta_50', 'LBP_Delta_51', 'LBP_Delta_52', 'LBP_Delta_53', 'LBP_Delta_54', 'LBP_Delta_55', 'LBP_Delta_56', 'LBP_Delta_57', 'LBP_Delta_58', 'LBP_Delta_59'})];
extractPredictorsFromTableFcn = @(t) t(:, predictorNames);
predictorExtractionFcn = @(x) extractPredictorsFromTableFcn(splitMatricesInTableFcn(x));
ensemblePredictFcn = @(x) predict(classificationEnsemble, x);
trainedClassifier.predictFcn = @(x) ensemblePredictFcn(predictorExtractionFcn(x));

% Add additional fields to the result struct
trainedClassifier.RequiredVariables = {'RegionCount', 'Region_A', 'Area_A', 'MajorAxisLength_A', 'MinorAxisLength_A', 'Eccentricity_A', 'Orientation_A', 'ConvexArea_A', 'FilledArea_A', 'EulerNumber_A', 'EquivDiameter_A', 'Solidity_A', 'Extent_A', 'Perimeter_A', 'Region_B', 'Area_B', 'MajorAxisLength_B', 'MinorAxisLength_B', 'Eccentricity_B', 'Orientation_B', 'ConvexArea_B', 'FilledArea_B', 'EulerNumber_B', 'EquivDiameter_B', 'Solidity_B', 'Extent_B', 'Perimeter_B', 'Region_Delta', 'Area_Delta', 'MajorAxisLength_Delta', 'MinorAxisLength_Delta', 'Eccentricity_Delta', 'Orientation_Delta', 'ConvexArea_Delta', 'FilledArea_Delta', 'EulerNumber_Delta', 'EquivDiameter_Delta', 'Solidity_Delta', 'Extent_Delta', 'Perimeter_Delta', 'Centroid_A', 'BoundingBox_A', 'LBP_A', 'Centroid_B', 'BoundingBox_B', 'LBP_B', 'LBP_Delta'};
trainedClassifier.ClassificationEnsemble = classificationEnsemble;
trainedClassifier.About = 'This struct is a trained model exported from Classification Learner R2017b.';
trainedClassifier.HowToPredict = sprintf('To make predictions on a new table, T, use: \n  yfit = c.predictFcn(T) \nreplacing ''c'' with the name of the variable that is this struct, e.g. ''trainedModel''. \n \nThe table, T, must contain the variables returned by: \n  c.RequiredVariables \nVariable formats (e.g. matrix/vector, datatype) must match the original training data. \nAdditional variables are ignored. \n \nFor more information, see <a href="matlab:helpview(fullfile(docroot, ''stats'', ''stats.map''), ''appclassification_exportmodeltoworkspace'')">How to predict using an exported model</a>.');

% Perform cross-validation
partitionedModel = crossval(trainedClassifier.ClassificationEnsemble, 'KFold', 5);

% Compute validation predictions
[validationPredictions, validationScores] = kfoldPredict(partitionedModel);

% Compute validation accuracy
validationAccuracy = 1 - kfoldLoss(partitionedModel, 'LossFun', 'ClassifError');
